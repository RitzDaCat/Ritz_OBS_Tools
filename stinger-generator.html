<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Stinger Transition Generator</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f7f9;
        }

        /* Layout */
        header {
            background-color: #2c3e50;
            color: white;
            padding: 1.5rem;
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Panels and sections */
        .panel {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        h2 {
            margin-bottom: 1rem;
            color: #2c3e50;
            font-size: 1.4rem;
        }

        .section-heading {
            background-color: #ecf0f1;
            padding: 0.5rem;
            margin: 1rem -1.5rem 1rem -1.5rem;
            border-left: 4px solid #3498db;
            font-weight: 600;
        }

        /* Form elements */
        .setting-group {
            margin-bottom: 1rem;
        }

        label {
            display: block;
            margin-bottom: 0.3rem;
            font-weight: 500;
            color: #555;
        }

        input[type="file"] {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        input[type="file"] + label {
            display: inline-block;
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        input[type="file"] + label:hover {
            background-color: #2980b9;
        }

        .hint {
            font-size: 0.8rem;
            color: #7f8c8d;
            margin-top: 0.5rem;
        }

        select, input[type="number"], input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 1rem;
            background-color: #f9f9f9;
        }

        input[type="color"] {
            height: 40px;
            width: 100%;
            margin-bottom: 1rem;
        }

        input[type="checkbox"] {
            margin-right: 0.5rem;
        }

        /* Buttons */
        .btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #95a5a6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            text-decoration: none;
            transition: background-color 0.3s;
        }

        .btn:hover {
            background-color: #7f8c8d;
        }

        .btn.primary {
            background-color: #3498db;
        }

        .btn.primary:hover {
            background-color: #2980b9;
        }

        .btn.success {
            background-color: #2ecc71;
        }

        .btn.success:hover {
            background-color: #27ae60;
        }

        .actions {
            display: flex;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .actions .btn {
            flex: 1;
        }

        /* Preview section */
        .canvas-container {
            position: relative;
            width: 100%;
            margin-bottom: 1rem;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                            linear-gradient(-45deg, #ccc 25%, transparent 25%),
                            linear-gradient(45deg, transparent 75%, #ccc 75%),
                            linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        #previewCanvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .transition-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: rgba(255, 0, 0, 0.7);
            pointer-events: none;
        }

        .preview-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .progress-container {
            flex: 1;
            height: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #3498db;
            transition: width 0.1s;
        }

        .status-message {
            min-width: 100px;
            text-align: right;
        }

        /* Download section */
        .download-actions {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .download-actions .btn {
            flex: 1;
        }

        .technical-details {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            font-family: monospace;
            white-space: pre-wrap;
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            background-color: white;
            padding: 2rem;
            border-radius: 8px;
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .spinner {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-progress-container {
            height: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 1rem;
        }

        .loading-progress-bar {
            height: 100%;
            width: 0;
            background-color: #3498db;
            transition: width 0.3s;
        }

        /* Audio upload styles */
        .audio-control {
            margin-top: 1rem;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        .audio-control.has-audio {
            background-color: #e1f5fe;
            border-color: #03a9f4;
        }

        .audio-feedback {
            display: flex;
            align-items: center;
            margin-top: 0.5rem;
        }

        .audio-status {
            flex: 1;
        }

        .audio-preview-btn {
            background-color: #03a9f4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
        }

        /* Timeline diagram */
        .timeline-diagram {
            width: 100%;
            height: 70px;
            margin: 1rem 0;
            position: relative;
            background-color: #f0f0f0;
            border-radius: 4px;
            overflow: hidden;
        }

        .timeline-section {
            position: absolute;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-align: center;
            line-height: 1.2;
        }

        .timeline-intro {
            left: 0;
            background-color: #3498db;
        }

        .timeline-hold {
            background-color: #2ecc71;
        }

        .timeline-outro {
            right: 0;
            background-color: #e74c3c;
        }

        .timeline-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* Responsive layout */
        @media (min-width: 768px) {
            .container {
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-areas:
                    "input preview"
                    "download download";
                gap: 1.5rem;
            }
            
            .input-section {
                grid-area: input;
            }
            
            .preview-section {
                grid-area: preview;
            }
            
            .download-section {
                grid-area: download;
            }
        }

        @media (max-width: 767px) {
            .actions {
                flex-direction: column;
            }
        }
    </style>
    <!-- Include fix-webm-duration library -->
    <script src="https://cdn.jsdelivr.net/npm/fix-webm-duration@1.0.6/fix-webm-duration.min.js"></script>
</head>
<body>
    <header>
        <h1>OBS Stinger Transition Generator</h1>
        <p>Create custom stinger transitions for OBS Studio directly in your browser</p>
    </header>

    <main>
        <div class="container">
            <section class="input-section">
                <!-- Image Upload Area -->
                <div class="panel">
                    <h2>Upload Image</h2>
                    <div class="upload-area">
                        <input type="file" id="imageUpload" accept=".png,.jpg,.jpeg">
                        <label for="imageUpload">Choose an image (PNG/JPG)</label>
                        <p class="hint">Transparent PNG recommended for best results</p>
                    </div>
                </div>

                <!-- Audio Upload Area -->
                <div class="panel">
                    <h2>Audio Settings</h2>
                    <div class="audio-control" id="audioControl">
                        <input type="file" id="audioUpload" accept="audio/*">
                        <label for="audioUpload">Upload Audio</label>
                        <p class="hint">Supported formats: MP3, WAV, OGG (optional)</p>
                        
                        <div class="audio-feedback">
                            <div class="audio-status" id="audioStatus">No audio selected</div>
                            <button class="audio-preview-btn" id="audioPreviewBtn" style="display: none;">Play/Pause</button>
                        </div>
                        
                        <div class="setting-group" style="margin-top: 1rem;">
                            <label for="audioVolume">Audio Volume</label>
                            <input type="range" id="audioVolume" min="0" max="100" value="100">
                        </div>
                    </div>
                </div>

                <!-- Transition Settings -->
                <div class="panel">
                    <h2>Transition Settings</h2>
                    
                    <!-- Timeline visualization -->
                    <div class="timeline-diagram" id="timelineDiagram">
                        <div class="timeline-section timeline-intro" id="timelineIntro">
                            Intro Effect
                        </div>
                        <div class="timeline-section timeline-hold" id="timelineHold">
                            Hold
                        </div>
                        <div class="timeline-section timeline-outro" id="timelineOutro">
                            Outro Effect
                        </div>
                        <div class="timeline-marker" id="timelineMarker"></div>
                    </div>
                    
                    <div class="section-heading">Intro Effect</div>
                    <div class="setting-group">
                        <label for="introEffect">Intro Effect</label>
                        <select id="introEffect">
                            <option value="left-to-right">Left to Right</option>
                            <option value="right-to-left">Right to Left</option>
                            <option value="top-to-bottom">Top to Bottom</option>
                            <option value="bottom-to-top">Bottom to Top</option>
                            <option value="fade-in">Fade In</option>
                            <option value="zoom-in">Zoom In</option>
                            <option value="pixelate">Pixelate</option>
                            <option value="circular-wipe">Circular Wipe</option>
                            <option value="horizontal-split">Horizontal Split</option>
                            <option value="vertical-split">Vertical Split</option>
                            <option value="glitch">Glitch</option>
                            <option value="blur-to-clear">Blur to Clear</option>
                            <option value="grayscale-to-color">Grayscale to Color</option>
                            <option value="venetian-blinds">Venetian Blinds</option>
                            <option value="diagonal-wipe">Diagonal Wipe</option>
                            <option value="bounce">Bounce</option>
                        </select>
                    </div>
                    
                    <div class="setting-group">
                        <label for="introDuration">Intro Duration (seconds)</label>
                        <input type="number" id="introDuration" min="0.5" max="10" step="0.1" value="1.5">
                    </div>
                    
                    <div class="section-heading">Hold</div>
                    <div class="setting-group">
                        <label for="holdDuration">Hold Duration (seconds)</label>
                        <input type="number" id="holdDuration" min="0" max="5" step="0.1" value="0.5">
                    </div>
                    
                    <div class="section-heading">Outro Effect</div>
                    <div class="setting-group">
                        <label for="outroEffect">Outro Effect</label>
                        <select id="outroEffect">
                            <option value="none">None (End with Hold)</option>
                            <option value="fade-out">Fade Out</option>
                            <option value="right-to-left">Right to Left</option>
                            <option value="left-to-right">Left to Right</option>
                            <option value="top-to-bottom">Top to Bottom</option>
                            <option value="bottom-to-top">Bottom to Top</option>
                            <option value="zoom-out">Zoom Out</option>
                            <option value="pixelate">Pixelate</option>
                            <option value="circular-wipe-reverse">Circular Wipe (Reverse)</option>
                            <option value="horizontal-split-reverse">Horizontal Split (Reverse)</option>
                            <option value="vertical-split-reverse">Vertical Split (Reverse)</option>
                            <option value="glitch">Glitch</option>
                        </select>
                    </div>
                    
                    <div class="setting-group">
                        <label for="outroDuration">Outro Duration (seconds)</label>
                        <input type="number" id="outroDuration" min="0.5" max="10" step="0.1" value="1.0">
                    </div>
                    
                    <div class="section-heading">Particle Effects</div>
                    <div class="setting-group">
                        <label for="particleEffect">Particle Effect</label>
                        <select id="particleEffect">
                            <option value="none">None</option>
                            <option value="confetti">Confetti</option>
                            <option value="sparks">Sparks</option>
                            <option value="bubbles">Bubbles</option>
                            <option value="smoke">Smoke</option>
                            <option value="stars">Stars</option>
                        </select>
                    </div>
                    
                    <div class="setting-group" id="particleSettings" style="display: none;">
                        <label for="particleColor">Particle Color</label>
                        <input type="color" id="particleColor" value="#ffffff">
                        
                        <label for="particleDensity">Particle Density</label>
                        <input type="range" id="particleDensity" min="1" max="100" value="50">
                    </div>
                    
                    <div class="section-heading">OBS Settings</div>
                    <div class="setting-group">
                        <label for="transitionPoint">Transition Point (%)</label>
                        <input type="range" id="transitionPoint" min="1" max="100" value="50">
                        <span id="transitionPointValue">50%</span>
                        <p class="hint">This is when OBS will switch scenes during the transition</p>
                    </div>
                    
                    <div class="section-heading">Output Settings</div>
                    <div class="setting-group">
                        <label for="frameRate">Frame Rate</label>
                        <select id="frameRate">
                            <option value="24">24 FPS</option>
                            <option value="25">25 FPS</option>
                            <option value="30" selected>30 FPS</option>
                            <option value="50">50 FPS</option>
                            <option value="60">60 FPS</option>
                        </select>
                    </div>
                    
                    <div class="setting-group">
                        <label for="transparencyToggle">Transparent Background</label>
                        <input type="checkbox" id="transparencyToggle" checked>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="actions">
                    <button id="previewBtn" class="btn primary">Preview Transition</button>
                    <button id="generateBtn" class="btn success">Generate Video</button>
                </div>
            </section>

            <section class="preview-section">
                <div class="panel">
                    <h2>Preview</h2>
                    <div class="canvas-container">
                        <canvas id="previewCanvas" width="1280" height="720"></canvas>
                        <div id="transitionMarker" class="transition-marker"></div>
                    </div>
                    
                    <div class="preview-controls">
                        <button id="playStopBtn" class="btn">Play</button>
                        <div class="progress-container">
                            <div id="progressBar" class="progress-bar"></div>
                        </div>
                        <span id="statusMessage" class="status-message">Ready</span>
                    </div>
                </div>
            </section>

            <section class="download-section" style="display: none;">
                <div class="panel">
                    <h2>Download</h2>
                    <p id="fileInfo">Size: 0 MB | Duration: 0s</p>
                    <div class="download-actions">
                        <a id="downloadBtn" class="btn success" download="transition.webm">Download Transition</a>
                        <button id="newTransitionBtn" class="btn">Create New Transition</button>
                    </div>
                    <details>
                        <summary>Technical Details</summary>
                        <div id="technicalDetails" class="technical-details">
                            <!-- Technical details will be filled by JavaScript -->
                        </div>
                    </details>
                </div>
            </section>
        </div>
    </main>

    <div id="loadingOverlay" class="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-progress-container">
                <div id="loadingProgressBar" class="loading-progress-bar"></div>
            </div>
            <p id="loadingStatusMessage">Initializing...</p>
        </div>
    </div>

    <script>
        // Main application logic
        document.addEventListener('DOMContentLoaded', function() {
            // Constants and globals
            const WIDTH = 1280;
            const HEIGHT = 720;
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            const transitionMarker = document.getElementById('transitionMarker');
            const progressBar = document.getElementById('progressBar');
            const statusMessage = document.getElementById('statusMessage');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const loadingProgressBar = document.getElementById('loadingProgressBar');
            const loadingStatusMessage = document.getElementById('loadingStatusMessage');
            const timelineDiagram = document.getElementById('timelineDiagram');
            const timelineIntro = document.getElementById('timelineIntro');
            const timelineHold = document.getElementById('timelineHold');
            const timelineOutro = document.getElementById('timelineOutro');
            const timelineMarker = document.getElementById('timelineMarker');
            
            // Global state variables
            let sourceImage = null;
            let audioBlob = null;
            let audioContext = null;
            let audioElement = null;
            let isPlaying = false;
            let animationFrameId = null;
            let startTime = 0;
            let generatedBlob = null;
            let frames = [];
            
            // Initialize UI event listeners
            initializeEventListeners();
            updateTimeline();
            
            function initializeEventListeners() {
                // Image upload
                document.getElementById('imageUpload').addEventListener('change', handleImageUpload);
                
                // Audio upload
                document.getElementById('audioUpload').addEventListener('change', handleAudioUpload);
                document.getElementById('audioPreviewBtn').addEventListener('click', toggleAudioPreview);
                
                // Particle effect toggle
                document.getElementById('particleEffect').addEventListener('change', function() {
                    const particleSettings = document.getElementById('particleSettings');
                    particleSettings.style.display = this.value !== 'none' ? 'block' : 'none';
                });
                
                // Transition point slider
                const transitionPointInput = document.getElementById('transitionPoint');
                const transitionPointValue = document.getElementById('transitionPointValue');
                
                transitionPointInput.addEventListener('input', function() {
                    const value = this.value;
                    transitionPointValue.textContent = `${value}%`;
                    updateTransitionMarker();
                });
                
                // Duration inputs
                document.getElementById('introDuration').addEventListener('input', updateTimeline);
                document.getElementById('holdDuration').addEventListener('input', updateTimeline);
                document.getElementById('outroDuration').addEventListener('input', updateTimeline);
                document.getElementById('outroEffect').addEventListener('change', function() {
                    const outroEffect = this.value;
                    const outroDurationInput = document.getElementById('outroDuration');
                    
                    if (outroEffect === 'none') {
                        outroDurationInput.disabled = true;
                        outroDurationInput.value = 0;
                    } else {
                        outroDurationInput.disabled = false;
                        if (outroDurationInput.value === '0') {
                            outroDurationInput.value = 1.0;
                        }
                    }
                    
                    updateTimeline();
                });
                
                // Preview and Generate buttons
                document.getElementById('previewBtn').addEventListener('click', previewTransition);
                document.getElementById('generateBtn').addEventListener('click', generateVideo);
                
                // Play/Stop button
                document.getElementById('playStopBtn').addEventListener('click', togglePlayback);
                
                // Create new transition button
                document.getElementById('newTransitionBtn').addEventListener('click', resetApplication);
                
                // Update transition marker position on resize
                window.addEventListener('resize', function() {
                    updateTransitionMarker();
                    updateTimeline();
                });
                
                // Initial transition marker position
                updateTransitionMarker();
            }
            
            function updateTimeline() {
                const introDuration = parseFloat(document.getElementById('introDuration').value);
                const holdDuration = parseFloat(document.getElementById('holdDuration').value);
                let outroDuration = parseFloat(document.getElementById('outroDuration').value);
                
                // If outro effect is "none", set outroDuration to 0
                if (document.getElementById('outroEffect').value === 'none') {
                    outroDuration = 0;
                }
                
                const totalDuration = introDuration + holdDuration + outroDuration;
                
                // Calculate widths as percentages of total
                const introWidth = (introDuration / totalDuration) * 100;
                const holdWidth = (holdDuration / totalDuration) * 100;
                const outroWidth = (outroDuration / totalDuration) * 100;
                
                // Update timeline sections
                timelineIntro.style.width = `${introWidth}%`;
                timelineHold.style.left = `${introWidth}%`;
                timelineHold.style.width = `${holdWidth}%`;
                timelineOutro.style.width = `${outroWidth}%`;
                
                // Update transition point marker
                const transitionPoint = parseInt(document.getElementById('transitionPoint').value);
                const markerPosition = (transitionPoint / 100) * 100; // Convert percentage to position
                timelineMarker.style.left = `${markerPosition}%`;
                
                // Update section labels
                timelineIntro.textContent = `Intro\n${introDuration}s`;
                timelineHold.textContent = `Hold\n${holdDuration}s`;
                
                if (outroDuration > 0) {
                    timelineOutro.textContent = `Outro\n${outroDuration}s`;
                    timelineOutro.style.display = 'flex';
                } else {
                    timelineOutro.style.display = 'none';
                }
            }
            
            function updateTransitionMarker() {
                const containerWidth = canvas.clientWidth;
                const transitionPoint = parseInt(document.getElementById('transitionPoint').value);
                const markerPosition = (containerWidth * transitionPoint) / 100;
                transitionMarker.style.left = `${markerPosition}px`;
            }
            
            function handleImageUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.onload = function() {
                        sourceImage = img;
                        drawInitialCanvas();
                        statusMessage.textContent = 'Image loaded';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            function handleAudioUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    audioBlob = new Blob([e.target.result], { type: file.type });
                    
                    // Create audio element for preview
                    if (audioElement) {
                        URL.revokeObjectURL(audioElement.src);
                    }
                    
                    audioElement = new Audio();
                    audioElement.src = URL.createObjectURL(audioBlob);
                    audioElement.volume = document.getElementById('audioVolume').value / 100;
                    
                    // Update audio controls
                    const audioControl = document.getElementById('audioControl');
                    const audioStatus = document.getElementById('audioStatus');
                    const audioPreviewBtn = document.getElementById('audioPreviewBtn');
                    
                    audioControl.classList.add('has-audio');
                    audioStatus.textContent = `Audio: ${file.name} (${formatFileSize(file.size)})`;
                    audioPreviewBtn.style.display = 'block';
                    
                    statusMessage.textContent = 'Audio loaded';
                };
                reader.readAsArrayBuffer(file);
            }
            
            function toggleAudioPreview() {
                if (!audioElement) return;
                
                if (audioElement.paused) {
                    audioElement.play();
                } else {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                }
            }
            
            function formatFileSize(bytes) {
                if (bytes < 1024) {
                    return bytes + ' B';
                } else if (bytes < 1024 * 1024) {
                    return (bytes / 1024).toFixed(1) + ' KB';
                } else {
                    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
                }
            }
            
            function drawInitialCanvas() {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                
                if (sourceImage) {
                    // Draw image centered on canvas
                    const scale = Math.min(WIDTH / sourceImage.width, HEIGHT / sourceImage.height);
                    const x = (WIDTH - sourceImage.width * scale) / 2;
                    const y = (HEIGHT - sourceImage.height * scale) / 2;
                    
                    ctx.drawImage(sourceImage, x, y, sourceImage.width * scale, sourceImage.height * scale);
                }
            }
            
            function previewTransition() {
                if (!sourceImage) {
                    alert('Please upload an image first');
                    return;
                }
                
                if (isPlaying) {
                    stopPlayback();
                }
                
                const introEffect = document.getElementById('introEffect').value;
                const outroEffect = document.getElementById('outroEffect').value;
                const particleEffect = document.getElementById('particleEffect').value;
                const introDuration = parseFloat(document.getElementById('introDuration').value) * 1000; // Convert to ms
                const holdDuration = parseFloat(document.getElementById('holdDuration').value) * 1000; // Convert to ms
                let outroDuration = parseFloat(document.getElementById('outroDuration').value) * 1000; // Convert to ms
                
                // If outro effect is "none", set outroDuration to 0
                if (outroEffect === 'none') {
                    outroDuration = 0;
                }
                
                const totalDuration = introDuration + holdDuration + outroDuration;
                
                // Reset audio if present
                if (audioElement) {
                    audioElement.currentTime = 0;
                    audioElement.volume = document.getElementById('audioVolume').value / 100;
                }
                
                // Start playback
                isPlaying = true;
                document.getElementById('playStopBtn').textContent = 'Stop';
                startTime = Date.now();
                
                if (audioElement) {
                    audioElement.play();
                }
                
                // Animation loop
                function animate() {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / totalDuration, 1);
                    
                    // Update progress bar
                    progressBar.style.width = `${progress * 100}%`;
                    
                    // Render the current frame based on which phase we're in
                    renderTransitionFrame(elapsed, introDuration, holdDuration, outroDuration, introEffect, outroEffect, particleEffect);
                    
                    // Continue animation if not complete
                    if (progress < 1 && isPlaying) {
                        animationFrameId = requestAnimationFrame(animate);
                    } else if (progress >= 1) {
                        stopPlayback();
                    }
                }
                
                animate();
            }
            
            function togglePlayback() {
                if (isPlaying) {
                    stopPlayback();
                } else {
                    previewTransition();
                }
            }
            
            function stopPlayback() {
                isPlaying = false;
                document.getElementById('playStopBtn').textContent = 'Play';
                
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                if (audioElement) {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                }
                
                // Reset canvas to initial state
                drawInitialCanvas();
                progressBar.style.width = '0%';
                statusMessage.textContent = 'Ready';
            }
            
            function renderTransitionFrame(elapsed, introDuration, holdDuration, outroDuration, introEffect, outroEffect, particleEffect) {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                
                if (!sourceImage) return;
                
                // Determine which phase we're in
                if (elapsed <= introDuration) {
                    // Phase 1: Intro effect
                    const introProgress = elapsed / introDuration;
                    applyTransitionEffect(ctx, sourceImage, introProgress, introEffect, false);
                    
                    // Show status
                    statusMessage.textContent = `Intro: ${Math.floor(introProgress * 100)}%`;
                } else if (elapsed <= introDuration + holdDuration) {
                    // Phase 2: Hold
                    applyTransitionEffect(ctx, sourceImage, 1, introEffect, false);
                    
                    // Show status
                    const holdElapsed = elapsed - introDuration;
                    const holdProgress = holdElapsed / holdDuration;
                    statusMessage.textContent = `Hold: ${Math.floor(holdProgress * 100)}%`;
                } else {
                    // Phase 3: Outro effect
                    const outroElapsed = elapsed - (introDuration + holdDuration);
                    const outroProgress = outroElapsed / outroDuration;
                    
                    if (outroEffect === 'none') {
                        // Just show the final frame of the intro effect
                        applyTransitionEffect(ctx, sourceImage, 1, introEffect, false);
                    } else {
                        // Apply the outro effect
                        applyTransitionEffect(ctx, sourceImage, outroProgress, outroEffect, true);
                    }
                    
                    // Show status
                    statusMessage.textContent = `Outro: ${Math.floor(outroProgress * 100)}%`;
                }
                
                // Apply particle effects if selected
                if (particleEffect !== 'none') {
                    const particleColor = document.getElementById('particleColor').value;
                    const particleDensity = parseInt(document.getElementById('particleDensity').value);
                    
                    // Calculate global progress for particles
                    const globalProgress = Math.min(elapsed / (introDuration + holdDuration + outroDuration), 1);
                    applyParticleEffect(ctx, globalProgress, particleEffect, particleColor, particleDensity);
                }
            }
            
            function applyTransitionEffect(ctx, image, progress, effectName, isOutro) {
                // Calculate image position for centered drawing
                const scale = Math.min(WIDTH / image.width, HEIGHT / image.height);
                const scaledWidth = image.width * scale;
                const scaledHeight = image.height * scale;
                const x = (WIDTH - scaledWidth) / 2;
                const y = (HEIGHT - scaledHeight) / 2;
                
                // For outro effects, invert progress if needed
                let effectProgress = progress;
                if (isOutro) {
                    // For some effects, we use inverted progress for the outro
                    if (effectName.includes('reverse')) {
                        effectProgress = 1 - progress;
                        // Remove "-reverse" from effectName to get the base effect
                        effectName = effectName.replace('-reverse', '');
                    } else if (effectName === 'fade-out') {
                        effectProgress = 1 - progress;
                        effectName = 'fade-in'; // Reuse fade-in logic with inverted progress
                    } else if (effectName === 'zoom-out') {
                        effectProgress = 1 - progress;
                        effectName = 'zoom-in'; // Reuse zoom-in logic with inverted progress
                    }
                }
                
                // Apply the requested effect based on name
                switch (effectName) {
                    case 'left-to-right':
                        const clipWidth = WIDTH * effectProgress;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, clipWidth, HEIGHT);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'right-to-left':
                        const rightClipWidth = WIDTH * effectProgress;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(WIDTH - rightClipWidth, 0, rightClipWidth, HEIGHT);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'top-to-bottom':
                        const clipHeight = HEIGHT * effectProgress;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, WIDTH, clipHeight);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'bottom-to-top':
                        const bottomClipHeight = HEIGHT * effectProgress;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, HEIGHT - bottomClipHeight, WIDTH, bottomClipHeight);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'fade-in':
                        ctx.globalAlpha = effectProgress;
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.globalAlpha = 1;
                        break;
                        
                    case 'zoom-in':
                        const zoomScale = 0.5 + (effectProgress * 0.5);
                        const zoomWidth = scaledWidth * zoomScale;
                        const zoomHeight = scaledHeight * zoomScale;
                        const zoomX = (WIDTH - zoomWidth) / 2;
                        const zoomY = (HEIGHT - zoomHeight) / 2;
                        ctx.drawImage(image, zoomX, zoomY, zoomWidth, zoomHeight);
                        break;
                        
                    case 'pixelate':
                        // Create a pixelated version of the image with decreasing pixel size
                        const maxPixelSize = 32;
                        const pixelSize = Math.max(1, Math.floor(maxPixelSize * (1 - effectProgress)));
                        
                        // Draw in low resolution to temporary canvas
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = WIDTH / pixelSize;
                        tempCanvas.height = HEIGHT / pixelSize;
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw to main canvas scaled up
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(tempCanvas, 0, 0, WIDTH, HEIGHT);
                        ctx.imageSmoothingEnabled = true;
                        break;
                        
                    case 'circular-wipe':
                        const radius = Math.sqrt(WIDTH * WIDTH + HEIGHT * HEIGHT) * effectProgress;
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(WIDTH / 2, HEIGHT / 2, radius, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'horizontal-split':
                        const splitHeight = HEIGHT / 2 * effectProgress;
                        
                        // Top half
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, WIDTH, splitHeight);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        
                        // Bottom half
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, HEIGHT - splitHeight, WIDTH, splitHeight);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'vertical-split':
                        const splitWidth = WIDTH / 2 * effectProgress;
                        
                        // Left half
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, splitWidth, HEIGHT);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        
                        // Right half
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(WIDTH - splitWidth, 0, splitWidth, HEIGHT);
                        ctx.clip();
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'glitch':
                        // Create a glitch effect with random offsets
                        const intensity = 0.5 - Math.abs(0.5 - effectProgress);
                        
                        // Draw the base image
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        
                        // Apply glitch effect if intensity is significant
                        if (intensity > 0.05) {
                            // Number of glitch slices
                            const slices = 10;
                            const sliceHeight = HEIGHT / slices;
                            
                            // Create RGB channel splits
                            for (let i = 0; i < slices; i++) {
                                // Skip random slices
                                if (Math.random() > 0.3) continue;
                                
                                // Random offset for this slice
                                const offsetX = (Math.random() - 0.5) * intensity * 100;
                                
                                // Get data from the original image
                                const imgData = ctx.getImageData(0, i * sliceHeight, WIDTH, sliceHeight);
                                
                                // Draw with offset
                                ctx.putImageData(imgData, offsetX, i * sliceHeight);
                                
                                // Random RGB shifts for some slices
                                if (Math.random() > 0.6) {
                                    const rgbData = ctx.getImageData(0, i * sliceHeight, WIDTH, sliceHeight);
                                    const data = rgbData.data;
                                    
                                    // Shift RGB channels
                                    for (let j = 0; j < data.length; j += 4) {
                                        // Randomly shift red or blue channel
                                        const channelToShift = Math.random() > 0.5 ? 0 : 2;
                                        data[j + channelToShift] = 255;
                                    }
                                    
                                    ctx.putImageData(rgbData, 0, i * sliceHeight);
                                }
                            }
                        }
                        break;
                        
                    case 'blur-to-clear':
                        // This effect is an approximation since canvas doesn't have a simple blur transition
                        // We'll manually implement using a temporary canvas and varying blur levels
                        
                        // Calculate blur amount (max at start, clear at end)
                        const blurAmount = 20 * (1 - effectProgress);
                        
                        if (blurAmount <= 0) {
                            // Just draw the image normally when fully clear
                            ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        } else {
                            // Create a temporary canvas for the blur effect
                            const tempCanvas = document.createElement('canvas');
                            tempCanvas.width = WIDTH;
                            tempCanvas.height = HEIGHT;
                            const tempCtx = tempCanvas.getContext('2d');
                            
                            // Draw the image to the temp canvas
                            tempCtx.drawImage(image, x, y, scaledWidth, scaledHeight);
                            
                            // Apply a blur-like effect using multiple shadow layers
                            ctx.save();
                            ctx.fillStyle = 'rgba(255,255,255,0)';
                            ctx.shadowColor = 'rgba(0,0,0,1)';
                            ctx.shadowBlur = blurAmount;
                            
                            // Draw the image using shadow blur
                            ctx.drawImage(tempCanvas, 0, 0);
                            ctx.restore();
                        }
                        break;
                        
                    case 'grayscale-to-color':
                        // Draw the base image
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        
                        // Apply grayscale filter with decreasing intensity
                        const grayscaleIntensity = 1 - effectProgress;
                        
                        if (grayscaleIntensity > 0) {
                            // Get image data
                            const imageData = ctx.getImageData(0, 0, WIDTH, HEIGHT);
                            const data = imageData.data;
                            
                            // Apply grayscale with fading intensity
                            for (let i = 0; i < data.length; i += 4) {
                                if (data[i + 3] > 0) { // Only process non-transparent pixels
                                    const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                                    
                                    // Blend between grayscale and original color
                                    data[i] = gray * grayscaleIntensity + data[i] * (1 - grayscaleIntensity);
                                    data[i + 1] = gray * grayscaleIntensity + data[i + 1] * (1 - grayscaleIntensity);
                                    data[i + 2] = gray * grayscaleIntensity + data[i + 2] * (1 - grayscaleIntensity);
                                }
                            }
                            
                            ctx.putImageData(imageData, 0, 0);
                        }
                        break;
                        
                    case 'venetian-blinds':
                        const blinds = 20; // Number of blinds
                        const blindHeight = HEIGHT / blinds;
                        const blindWidth = WIDTH * effectProgress;
                        
                        for (let i = 0; i < blinds; i++) {
                            ctx.save();
                            ctx.beginPath();
                            ctx.rect(0, i * blindHeight, blindWidth, blindHeight);
                            ctx.clip();
                            ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                            ctx.restore();
                        }
                        break;
                        
                    case 'diagonal-wipe':
                        // Calculate the diagonal length of the canvas
                        const diagonal = Math.sqrt(WIDTH * WIDTH + HEIGHT * HEIGHT);
                        const diagonalProgress = diagonal * effectProgress;
                        
                        // Calculate the equation of the moving line
                        // Line equation: ax + by + c = 0
                        const a = HEIGHT / WIDTH;
                        const b = -1;
                        const c = -WIDTH * effectProgress;
                        
                        ctx.save();
                        ctx.beginPath();
                        
                        // Create a clip path for one side of the diagonal line
                        ctx.moveTo(0, 0);
                        ctx.lineTo(WIDTH, 0);
                        
                        // Check if the line has entered the canvas from the right
                        if (effectProgress > WIDTH / diagonal) {
                            ctx.lineTo(WIDTH, (a * WIDTH + c) / -b);
                        } else {
                            ctx.lineTo(c / -a, 0);
                        }
                        
                        // Close the path
                        ctx.lineTo(0, 0);
                        ctx.clip();
                        
                        // Draw the image within the clip area
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        ctx.restore();
                        break;
                        
                    case 'bounce':
                        // Bounce effect with easing
                        let bounceProgress = effectProgress;
                        
                        // Apply an elastic bounce curve
                        if (effectProgress < 0.9) {
                            // Scale up as we progress
                            const elasticScale = 1 + Math.sin(effectProgress * Math.PI) * 0.1;
                            const bounceX = (WIDTH - scaledWidth * elasticScale) / 2;
                            const bounceY = (HEIGHT - scaledHeight * elasticScale) / 2;
                            
                            ctx.drawImage(image, bounceX, bounceY, scaledWidth * elasticScale, scaledHeight * elasticScale);
                        } else {
                            // Settle to normal size in the last 10%
                            const finalProgress = (effectProgress - 0.9) / 0.1;
                            const finalScale = 1.1 - (finalProgress * 0.1);
                            const finalX = (WIDTH - scaledWidth * finalScale) / 2;
                            const finalY = (HEIGHT - scaledHeight * finalScale) / 2;
                            
                            ctx.drawImage(image, finalX, finalY, scaledWidth * finalScale, scaledHeight * finalScale);
                        }
                        break;
                        
                    default:
                        // Default to drawing the full image
                        ctx.drawImage(image, x, y, scaledWidth, scaledHeight);
                        break;
                }
            }
            
            function applyParticleEffect(ctx, progress, effectName, color, density) {
                // Skip if effect is 'none'
                if (effectName === 'none') return;
                
                // Calculate the number of particles based on density (1-100)
                const baseParticleCount = 50;
                const particleCount = Math.floor(baseParticleCount * (density / 50));
                
                // Generate particles if they don't exist or are for a different effect
                if (!window.particles || window.particleEffectName !== effectName) {
                    window.particles = [];
                    window.particleEffectName = effectName;
                    
                    for (let i = 0; i < particleCount; i++) {
                        window.particles.push(createParticle(effectName, color));
                    }
                }
                
                // Update and draw particles
                for (let i = 0; i < window.particles.length; i++) {
                    const particle = window.particles[i];
                    
                    // Update particle position and properties based on progress
                    updateParticle(particle, progress, effectName);
                    
                    // Draw the particle
                    drawParticle(ctx, particle, effectName, color);
                }
            }
            
            function createParticle(effectName, color) {
                // Base particle object with common properties
                const particle = {
                    x: Math.random() * WIDTH,
                    y: Math.random() * HEIGHT,
                    size: 0,
                    speed: 0,
                    opacity: 0,
                    angle: Math.random() * Math.PI * 2,
                    color: color
                };
                
                // Customize based on effect type
                switch (effectName) {
                    case 'confetti':
                        particle.x = Math.random() * WIDTH;
                        particle.y = -Math.random() * HEIGHT * 0.5; // Start above the screen
                        particle.size = 3 + Math.random() * 7;
                        particle.speed = 1 + Math.random() * 3;
                        particle.angle = Math.random() * Math.PI * 2;
                        particle.rotationSpeed = (Math.random() - 0.5) * 0.1;
                        particle.color = Math.random() > 0.5 ? color : getRandomColor();
                        break;
                        
                    case 'sparks':
                        particle.x = WIDTH / 2;
                        particle.y = HEIGHT / 2;
                        particle.size = 1 + Math.random() * 3;
                        particle.speed = 2 + Math.random() * 5;
                        particle.angle = Math.random() * Math.PI * 2;
                        particle.lifespan = 0.3 + Math.random() * 0.7; // When to start fading (0-1)
                        break;
                        
                    case 'bubbles':
                        particle.x = Math.random() * WIDTH;
                        particle.y = HEIGHT + Math.random() * HEIGHT * 0.2; // Start below the screen
                        particle.size = 5 + Math.random() * 15;
                        particle.speed = 0.5 + Math.random() * 2;
                        particle.opacity = 0.4 + Math.random() * 0.3;
                        break;
                        
                    case 'smoke':
                        particle.x = Math.random() * WIDTH;
                        particle.y = HEIGHT;
                        particle.size = 20 + Math.random() * 30;
                        particle.speed = 0.2 + Math.random() * 1;
                        particle.opacity = 0.1 + Math.random() * 0.2;
                        particle.growFactor = 1.01 + Math.random() * 0.02;
                        break;
                        
                    case 'stars':
                        particle.x = Math.random() * WIDTH;
                        particle.y = Math.random() * HEIGHT;
                        particle.size = 1 + Math.random() * 3;
                        particle.twinkleSpeed = 0.03 + Math.random() * 0.05;
                        particle.twinkleOffset = Math.random() * Math.PI * 2;
                        break;
                }
                
                return particle;
            }
            
            function updateParticle(particle, progress, effectName) {
                // Update particle based on effect type and animation progress
                switch (effectName) {
                    case 'confetti':
                        // Move downward and rotate
                        particle.y += particle.speed * 5;
                        particle.angle += particle.rotationSpeed;
                        
                        // Reset if off-screen
                        if (particle.y > HEIGHT + particle.size) {
                            particle.y = -particle.size;
                            particle.x = Math.random() * WIDTH;
                        }
                        
                        // Set opacity based on progress
                        particle.opacity = progress < 0.2 ? progress / 0.2 : 1;
                        break;
                        
                    case 'sparks':
                        // Calculate active status based on progress and lifespan
                        const sparkActive = progress < particle.lifespan;
                        
                        if (sparkActive) {
                            // Move outward from center
                            const distanceFactor = progress / particle.lifespan;
                            const distance = particle.speed * distanceFactor * WIDTH * 0.4;
                            
                            particle.x = WIDTH / 2 + Math.cos(particle.angle) * distance;
                            particle.y = HEIGHT / 2 + Math.sin(particle.angle) * distance;
                            
                            // Fade out as it reaches its max distance
                            particle.opacity = 1 - distanceFactor;
                        } else {
                            particle.opacity = 0;
                        }
                        break;
                        
                    case 'bubbles':
                        // Move upward
                        particle.y -= particle.speed * 3;
                        
                        // Add subtle horizontal movement
                        particle.x += Math.sin(progress * 10 + particle.angle) * 0.5;
                        
                        // Reset if off-screen
                        if (particle.y < -particle.size) {
                            particle.y = HEIGHT + particle.size;
                            particle.x = Math.random() * WIDTH;
                        }
                        break;
                        
                    case 'smoke':
                        // Rise and expand
                        particle.y -= particle.speed * 2;
                        particle.size *= particle.growFactor;
                        
                        // Add drift
                        particle.x += Math.sin(progress * 5 + particle.angle) * 0.5;
                        
                        // Fade out as it rises
                        particle.opacity = Math.max(0, particle.opacity - 0.002);
                        
                        // Reset if completely faded or too large
                        if (particle.opacity <= 0 || particle.size > 200) {
                            particle.y = HEIGHT;
                            particle.x = Math.random() * WIDTH;
                            particle.size = 20 + Math.random() * 30;
                            particle.opacity = 0.1 + Math.random() * 0.2;
                        }
                        break;
                        
                    case 'stars':
                        // Twinkle effect
                        particle.opacity = 0.3 + 0.7 * Math.sin(progress * 10 + particle.twinkleOffset + particle.twinkleSpeed * 100);
                        break;
                }
            }
            
            function drawParticle(ctx, particle, effectName, baseColor) {
                // Skip drawing if fully transparent
                if (particle.opacity <= 0) return;
                
                ctx.save();
                
                // Set global alpha for transparency
                ctx.globalAlpha = particle.opacity;
                
                switch (effectName) {
                    case 'confetti':
                        // Draw rotated rectangle
                        ctx.translate(particle.x, particle.y);
                        ctx.rotate(particle.angle);
                        
                        ctx.fillStyle = particle.color;
                        ctx.fillRect(-particle.size / 2, -particle.size / 2, particle.size, particle.size);
                        break;
                        
                    case 'sparks':
                        // Draw as small bright circles
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add glow effect
                        ctx.globalAlpha = particle.opacity * 0.5;
                        ctx.filter = 'blur(2px)';
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.filter = 'none';
                        break;
                        
                    case 'bubbles':
                        // Draw circle with highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Add highlight
                        ctx.globalAlpha = particle.opacity * 0.7;
                        ctx.beginPath();
                        ctx.arc(particle.x - particle.size * 0.3, particle.y - particle.size * 0.3, particle.size * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'smoke':
                        // Create a gradient for smoke effect
                        const gradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size
                        );
                        
                        // Parse the color to get RGB components
                        const r = parseInt(baseColor.substring(1, 3), 16);
                        const g = parseInt(baseColor.substring(3, 5), 16);
                        const b = parseInt(baseColor.substring(5, 7), 16);
                        
                        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${particle.opacity})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'stars':
                        // Draw a star shape with 5 points
                        ctx.fillStyle = particle.color;
                        
                        // Draw star
                        const outerRadius = particle.size;
                        const innerRadius = particle.size * 0.4;
                        const spikes = 5;
                        
                        ctx.beginPath();
                        ctx.translate(particle.x, particle.y);
                        ctx.moveTo(0, -outerRadius);
                        
                        for (let i = 0; i < spikes; i++) {
                            ctx.rotate(Math.PI / spikes);
                            ctx.lineTo(0, -innerRadius);
                            ctx.rotate(Math.PI / spikes);
                            ctx.lineTo(0, -outerRadius);
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add glow
                        ctx.globalAlpha = particle.opacity * 0.5;
                        ctx.filter = 'blur(2px)';
                        ctx.fill();
                        ctx.filter = 'none';
                        break;
                }
                
                ctx.restore();
            }
            
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            
            function generateVideo() {
                if (!sourceImage) {
                    alert('Please upload an image first');
                    return;
                }
                
                // Get settings
                const introEffect = document.getElementById('introEffect').value;
                const outroEffect = document.getElementById('outroEffect').value;
                const particleEffect = document.getElementById('particleEffect').value;
                const introDuration = parseFloat(document.getElementById('introDuration').value);
                const holdDuration = parseFloat(document.getElementById('holdDuration').value);
                let outroDuration = parseFloat(document.getElementById('outroDuration').value);
                
                // If outro effect is "none", set outroDuration to 0
                if (outroEffect === 'none') {
                    outroDuration = 0;
                }
                
                const totalDuration = introDuration + holdDuration + outroDuration;
                const frameRate = parseInt(document.getElementById('frameRate').value);
                const transitionPoint = parseInt(document.getElementById('transitionPoint').value);
                const useTransparency = document.getElementById('transparencyToggle').checked;
                
                // Particle effect settings
                const particleColor = document.getElementById('particleColor').value;
                const particleDensity = parseInt(document.getElementById('particleDensity').value);
                
                // Show loading overlay
                loadingOverlay.style.display = 'flex';
                loadingProgressBar.style.width = '0%';
                loadingStatusMessage.textContent = 'Preparing to generate video...';
                
                // Pre-render all frames
                setTimeout(() => {
                    preRenderFrames(
                        introEffect,
                        outroEffect,
                        particleEffect,
                        particleColor,
                        particleDensity,
                        introDuration * 1000,
                        holdDuration * 1000,
                        outroDuration * 1000,
                        frameRate,
                        useTransparency
                    );
                }, 100); // Small delay to allow the UI to update
            }
            
            function preRenderFrames(introEffect, outroEffect, particleEffect, particleColor, particleDensity, 
                                    introDuration, holdDuration, outroDuration, frameRate, useTransparency) {
                const totalDuration = introDuration + holdDuration + outroDuration;
                const totalFrames = Math.ceil(totalDuration / (1000 / frameRate));
                
                loadingStatusMessage.textContent = `Pre-rendering frames (0/${totalFrames})...`;
                
                // Create an offscreen canvas for rendering frames
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = WIDTH;
                offscreenCanvas.height = HEIGHT;
                const offscreenCtx = offscreenCanvas.getContext('2d');
                
                // Clear frames array
                frames = [];
                
                // Pre-render each frame
                let currentFrame = 0;
                
                function renderNextFrame() {
                    if (currentFrame < totalFrames) {
                        // Calculate time for this frame
                        const frameTime = currentFrame * (1000 / frameRate);
                        
                        // Clear canvas with transparency if needed
                        offscreenCtx.clearRect(0, 0, WIDTH, HEIGHT);
                        
                        // Render the frame for the current time
                        renderTransitionFrame(
                            frameTime,
                            introDuration,
                            holdDuration,
                            outroDuration,
                            introEffect,
                            outroEffect,
                            particleEffect
                        );
                        
                        // Copy the main canvas to the offscreen canvas
                        offscreenCtx.drawImage(canvas, 0, 0);
                        
                        // Store the frame data
                        frames.push({
                            imageData: offscreenCanvas.toDataURL('image/png'),
                            timestamp: frameTime
                        });
                        
                        // Update progress
                        currentFrame++;
                        const progress = (currentFrame / totalFrames) * 50; // First 50% of the process
                        loadingProgressBar.style.width = `${progress}%`;
                        loadingStatusMessage.textContent = `Pre-rendering frames (${currentFrame}/${totalFrames})...`;
                        
                        // Process next frame asynchronously to avoid blocking UI
                        setTimeout(renderNextFrame, 0);
                    } else {
                        // All frames rendered, proceed to create video
                        loadingStatusMessage.textContent = 'Creating video...';
                        setTimeout(() => {
                            createVideo(
                                frames,
                                frameRate,
                                totalDuration,
                                transitionPoint,
                                useTransparency
                            );
                        }, 100);
                    }
                }
                
                // Start rendering frames
                renderNextFrame();
            }
            
            async function createVideo(frames, frameRate, totalDuration, transitionPoint, useTransparency) {
                try {
                    // Create recording canvas
                    const recordCanvas = document.createElement('canvas');
                    recordCanvas.width = WIDTH;
                    recordCanvas.height = HEIGHT;
                    const recordCtx = recordCanvas.getContext('2d');
                    
                    // Set up MediaRecorder with appropriate options
                    const stream = recordCanvas.captureStream(frameRate);
                    
                    // Add audio track if present
                    if (audioBlob) {
                        try {
                            // Create audio element for the recording
                            const audioElement = new Audio();
                            audioElement.src = URL.createObjectURL(audioBlob);
                            
                            // Set volume
                            audioElement.volume = document.getElementById('audioVolume').value / 100;
                            
                            // Set up audio context
                            if (!audioContext) {
                                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            }
                            
                            // Create media source from audio element
                            const source = audioContext.createMediaElementSource(audioElement);
                            const destination = audioContext.createMediaStreamDestination();
                            
                            // Connect audio
                            source.connect(destination);
                            
                            // Add audio tracks to the stream
                            destination.stream.getAudioTracks().forEach(track => {
                                stream.addTrack(track);
                            });
                            
                            // Play audio with the recording
                            audioElement.play();
                            
                            loadingStatusMessage.textContent = 'Creating video with audio...';
                        } catch (error) {
                            console.error('Error adding audio to video:', error);
                            loadingStatusMessage.textContent = 'Creating video without audio (audio error)...';
                        }
                    }
                    
                    // Calculate video options
                    const options = {
                        mimeType: useTransparency ? 'video/webm;codecs=vp8' : 'video/webm;codecs=vp9',
                        videoBitsPerSecond: 5000000 // 5 Mbps
                    };
                    
                    // Create MediaRecorder
                    const recorder = new MediaRecorder(stream, options);
                    
                    // Store recorded chunks
                    const chunks = [];
                    recorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    // Handle recording completion
                    recorder.onstop = async () => {
                        try {
                            // Combine chunks
                            const recordedBlob = new Blob(chunks, { type: 'video/webm' });
                            
                            // Use fix-webm-duration to fix the metadata
                            loadingStatusMessage.textContent = 'Fixing video metadata...';
                            
                            let fixedBlob;
                            try {
                                // Use the fix-webm-duration library
                                fixedBlob = await new Promise((resolve) => {
                                    ysFixWebmDuration(recordedBlob, totalDuration, resolve, { logger: false });
                                });
                            } catch (error) {
                                console.error('Error fixing WebM duration:', error);
                                fixedBlob = recordedBlob; // Use original blob if fixing fails
                            }
                            
                            // Create download URL
                            const transitionPointMs = Math.floor(totalDuration * (transitionPoint / 100));
                            const durationSec = (totalDuration / 1000).toFixed(1);
                            const filename = `transition_${transitionPointMs}ms_${durationSec}s.webm`;
                            
                            // Update UI with file info
                            generatedBlob = fixedBlob;
                            const fileSizeMB = (fixedBlob.size / (1024 * 1024)).toFixed(2);
                            document.getElementById('fileInfo').textContent = 
                                `Size: ${fileSizeMB} MB | Duration: ${durationSec}s | Transition Point: ${transitionPointMs}ms`;
                            
                            // Set download link
                            const downloadBtn = document.getElementById('downloadBtn');
                            downloadBtn.href = URL.createObjectURL(fixedBlob);
                            downloadBtn.download = filename;
                            
                            // Get the effect names (formatting for display)
                            const introEffectName = document.getElementById('introEffect').options[document.getElementById('introEffect').selectedIndex].text;
                            let outroEffectName = 'None';
                            if (document.getElementById('outroEffect').value !== 'none') {
                                outroEffectName = document.getElementById('outroEffect').options[document.getElementById('outroEffect').selectedIndex].text;
                            }
                            
                            // Update technical details
                            document.getElementById('technicalDetails').textContent = 
                                `Video Format: WebM ${useTransparency ? '(VP8 with alpha)' : '(VP9)'}\n` +
                                `Resolution: ${WIDTH}x${HEIGHT} pixels\n` +
                                `Frame Rate: ${frameRate} FPS\n` +
                                `Total Frames: ${frames.length}\n` +
                                `Intro Effect: ${introEffectName}\n` +
                                `Hold Duration: ${document.getElementById('holdDuration').value}s\n` +
                                `Outro Effect: ${outroEffectName}\n` +
                                `Particle Effect: ${document.getElementById('particleEffect').options[document.getElementById('particleEffect').selectedIndex].text}\n` +
                                `OBS Transition Point: ${transitionPointMs}ms\n` +
                                `Has Audio: ${audioBlob ? 'Yes' : 'No'}\n` +
                                `File Size: ${fileSizeMB} MB`;
                            
                            // Show download section
                            document.querySelector('.download-section').style.display = 'block';
                            
                            // Hide loading overlay
                            loadingOverlay.style.display = 'none';
                            
                            // Scroll to download section
                            document.querySelector('.download-section').scrollIntoView({ behavior: 'smooth' });
                        } catch (error) {
                            console.error('Error creating video:', error);
                            loadingStatusMessage.textContent = 'Error creating video: ' + error.message;
                            loadingOverlay.style.display = 'none';
                        }
                    };
                    
                    // Start recording
                    recorder.start(1000); // Use 1-second time slices for better metadata
                    
                    // Track the recording start time
                    const startTime = Date.now();
                    let frameIndex = 0;
                    let animationFrame = null;
                    
                    // Function to render each frame at the appropriate time
                    function renderVideoFrame() {
                        // Calculate elapsed time
                        const elapsed = Date.now() - startTime;
                        
                        // Find the appropriate frame to render
                        while (frameIndex < frames.length && frames[frameIndex].timestamp <= elapsed) {
                            frameIndex++;
                        }
                        
                        // Draw the current frame or the last frame if we've gone past all frames
                        const frameToRender = frames[Math.min(frameIndex, frames.length - 1)];
                        
                        // Create an image from the frame data and draw it
                        const img = new Image();
                        img.onload = () => {
                            recordCtx.clearRect(0, 0, WIDTH, HEIGHT);
                            recordCtx.drawImage(img, 0, 0);
                        };
                        img.src = frameToRender.imageData;
                        
                        // Update progress
                        const progress = 50 + (elapsed / totalDuration) * 50; // Last 50% of the process
                        loadingProgressBar.style.width = `${Math.min(progress, 99)}%`;
                        loadingStatusMessage.textContent = `Recording video... ${Math.floor(elapsed / totalDuration * 100)}%`;
                        
                        // Continue animation if we haven't reached the end
                        if (elapsed < totalDuration) {
                            animationFrame = requestAnimationFrame(renderVideoFrame);
                        } else {
                            // Stop recording
                            recorder.stop();
                            cancelAnimationFrame(animationFrame);
                            loadingProgressBar.style.width = '100%';
                            loadingStatusMessage.textContent = 'Finalizing video...';
                        }
                    }
                    
                    // Start rendering frames
                    renderVideoFrame();
                } catch (error) {
                    console.error('Error in video creation:', error);
                    loadingStatusMessage.textContent = 'Error creating video: ' + error.message;
                    loadingOverlay.style.display = 'none';
                }
            }
            
            function resetApplication() {
                // Hide download section
                document.querySelector('.download-section').style.display = 'none';
                
                // Reset canvas
                drawInitialCanvas();
                
                // Reset progress and status
                progressBar.style.width = '0%';
                statusMessage.textContent = 'Ready';
                
                // Revoke any object URLs to prevent memory leaks
                if (generatedBlob) {
                    URL.revokeObjectURL(document.getElementById('downloadBtn').href);
                    generatedBlob = null;
                }
                
                // Scroll to top
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
    </script>
</body>
</html>