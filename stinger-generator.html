<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBS Stinger Transition Generator</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header Styles */
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            border-radius: 8px;
        }

        header h1 {
            margin-bottom: 10px;
        }

        /* Main Layout */
        main {
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 30px;
        }

        @media (max-width: 1000px) {
            main {
                grid-template-columns: 1fr;
            }
        }

        /* Section Styling */
        section {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h2 {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
            color: #2c3e50;
        }

        /* Form Styling */
        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input[type="file"],
        input[type="number"],
        input[type="range"],
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }

        input[type="color"] {
            width: 50px;
            height: 30px;
            border: 1px solid #ddd;
        }

        .checkbox {
            display: flex;
            align-items: center;
        }

        .checkbox input {
            margin-right: 10px;
        }

        .checkbox label {
            margin-bottom: 0;
        }

        .hint {
            font-size: 0.8rem;
            color: #666;
            margin-top: 2px;
        }

        /* Button Styling */
        button, .download-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 500;
            text-align: center;
            display: inline-block;
        }

        button:hover, .download-button:hover {
            background-color: #2980b9;
        }

        #generateBtn {
            background-color: #2ecc71;
        }

        #generateBtn:hover {
            background-color: #27ae60;
        }

        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        /* Preview Section */
        .canvas-container {
            position: relative;
            width: 100%;
            background-image: linear-gradient(45deg, #ccc 25%, transparent 25%),
                            linear-gradient(-45deg, #ccc 25%, transparent 25%),
                            linear-gradient(45deg, transparent 75%, #ccc 75%),
                            linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            margin-bottom: 15px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .preview-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-bar {
            height: 100%;
            width: 0;
            background-color: #3498db;
            border-radius: 5px;
        }

        .transition-marker {
            position: absolute;
            top: 0;
            height: 100%;
            width: 2px;
            background-color: rgba(255, 0, 0, 0.7);
            pointer-events: none;
        }

        .status-message {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            display: none;
        }

        .status-message.info {
            display: block;
            border-left: 3px solid #3498db;
            background-color: #e1f0fa;
        }

        .status-message.success {
            display: block;
            border-left: 3px solid #2ecc71;
            background-color: #e8f8f5;
        }

        .status-message.error {
            display: block;
            border-left: 3px solid #e74c3c;
            background-color: #fdedeb;
        }

        /* Download Section */
        .download-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .download-button {
            background-color: #9b59b6;
            text-decoration: none;
            padding: 12px 20px;
            font-size: 1.1rem;
        }

        .download-button:hover {
            background-color: #8e44ad;
        }

        #newTransitionBtn {
            background-color: #34495e;
        }

        #newTransitionBtn:hover {
            background-color: #2c3e50;
        }

        /* Footer */
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>OBS Stinger Transition Generator</h1>
            <p>Create customized stinger transitions for OBS Studio</p>
        </header>

        <main>
            <section class="input-section">
                <h2>Transition Settings</h2>
                <form id="transitionForm">
                    <!-- Image Upload -->
                    <div class="form-group">
                        <label for="imageUpload">Upload Image:</label>
                        <input type="file" id="imageUpload" accept="image/*" required>
                        <p class="hint">Supports PNG with transparency</p>
                    </div>

                    <!-- Audio Upload -->
                    <div class="form-group">
                        <label for="audioUpload">Upload Audio (Optional):</label>
                        <input type="file" id="audioUpload" accept="audio/*">
                    </div>

                    <!-- Transition Effect -->
                    <div class="form-group">
                        <label for="transitionEffect">Transition Effect:</label>
                        <select id="transitionEffect">
                            <option value="leftToRight">Left to Right</option>
                            <option value="rightToLeft">Right to Left</option>
                            <option value="topToBottom">Top to Bottom</option>
                            <option value="bottomToTop">Bottom to Top</option>
                            <option value="fade">Fade In</option>
                            <option value="zoom">Zoom In</option>
                            <option value="pixelate">Pixelate</option>
                            <option value="circularWipe">Circular Wipe</option>
                            <option value="splitHorizontal">Split Horizontal</option>
                            <option value="splitVertical">Split Vertical</option>
                            <option value="glitch">Glitch</option>
                            <option value="blurToClear">Blur to Clear</option>
                            <option value="grayscaleToColor">Grayscale to Color</option>
                            <option value="venetianBlinds">Venetian Blinds</option>
                            <option value="diagonalWipe">Diagonal Wipe</option>
                            <option value="bounce">Bounce</option>
                        </select>
                    </div>

                    <!-- Particle Effects -->
                    <div class="form-group">
                        <label for="particleEffect">Particle Effect:</label>
                        <select id="particleEffect">
                            <option value="none">None</option>
                            <option value="confetti">Confetti</option>
                            <option value="sparks">Sparks</option>
                            <option value="bubbles">Bubbles</option>
                            <option value="smoke">Smoke</option>
                            <option value="stars">Stars</option>
                        </select>
                    </div>

                    <!-- Particle Color -->
                    <div class="form-group">
                        <label for="particleColor">Particle Color:</label>
                        <input type="color" id="particleColor" value="#ffffff">
                    </div>

                    <!-- Particle Density -->
                    <div class="form-group">
                        <label for="particleDensity">Particle Density:</label>
                        <input type="range" id="particleDensity" min="1" max="100" value="50">
                        <span id="particleDensityValue">50</span>
                    </div>

                    <!-- Audio Volume -->
                    <div class="form-group">
                        <label for="audioVolume">Audio Volume:</label>
                        <input type="range" id="audioVolume" min="0" max="100" value="100">
                        <span id="audioVolumeValue">100%</span>
                    </div>

                    <!-- Transition Duration -->
                    <div class="form-group">
                        <label for="transitionDuration">Transition Duration (ms):</label>
                        <input type="number" id="transitionDuration" min="500" max="5000" value="1000">
                    </div>

                    <!-- Hold Time -->
                    <div class="form-group">
                        <label for="holdTime">Hold Time at End (ms):</label>
                        <input type="number" id="holdTime" min="0" max="3000" value="500">
                    </div>

                    <!-- Transition Point -->
                    <div class="form-group">
                        <label for="transitionPoint">Transition Point (%):</label>
                        <input type="range" id="transitionPoint" min="1" max="99" value="50">
                        <span id="transitionPointValue">50%</span>
                    </div>

                    <!-- Show Transition Marker -->
                    <div class="form-group checkbox">
                        <input type="checkbox" id="showTransitionMarker" checked>
                        <label for="showTransitionMarker">Show Transition Point Marker</label>
                    </div>

                    <!-- Format Selector -->
                    <div class="form-group">
                        <label for="outputFormat">Output Format:</label>
                        <select id="outputFormat">
                            <option value="webm">WebM (with transparency)</option>
                            <option value="mp4">MP4 (no transparency)</option>
                        </select>
                    </div>

                    <!-- Transparent Background -->
                    <div class="form-group checkbox">
                        <input type="checkbox" id="transparentBg" checked>
                        <label for="transparentBg">Transparent Background</label>
                    </div>

                    <!-- Action Buttons -->
                    <div class="buttons">
                        <button type="button" id="previewBtn">Preview</button>
                        <button type="button" id="generateBtn">Generate Video</button>
                    </div>
                </form>
            </section>

            <section class="preview-section">
                <h2>Preview</h2>
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="previewCanvas" width="1280" height="720"></canvas>
                    <div id="transitionMarker" class="transition-marker"></div>
                </div>
                
                <div class="preview-controls">
                    <button id="playPreviewBtn">Play Preview</button>
                    <div class="progress-container">
                        <div id="previewProgress" class="progress-bar"></div>
                    </div>
                </div>

                <div id="generationStatus" class="status-message"></div>
                
                <div id="downloadContainer" class="download-container" style="display: none;">
                    <a id="downloadLink" class="download-button">Download Transition</a>
                    <button id="newTransitionBtn">Create New Transition</button>
                </div>
            </section>
        </main>

        <footer>
            <p>OBS Stinger Transition Generator | Created for streaming professionals</p>
        </footer>
    </div>

    <script>
        // OBS Stinger Transition Generator
        // Main JavaScript functionality

        // Configuration
        const CONFIG = {
            width: 1280,
            height: 720,
            fps: 60,
            defaultDuration: 1000, // ms
            defaultHoldTime: 500,  // ms
            defaultTransitionPoint: 50 // percent
        };

        // DOM Elements
        const elements = {
            imageUpload: document.getElementById('imageUpload'),
            audioUpload: document.getElementById('audioUpload'),
            transitionEffect: document.getElementById('transitionEffect'),
            particleEffect: document.getElementById('particleEffect'),
            particleColor: document.getElementById('particleColor'),
            particleDensity: document.getElementById('particleDensity'),
            particleDensityValue: document.getElementById('particleDensityValue'),
            audioVolume: document.getElementById('audioVolume'),
            audioVolumeValue: document.getElementById('audioVolumeValue'),
            transitionDuration: document.getElementById('transitionDuration'),
            holdTime: document.getElementById('holdTime'),
            transitionPoint: document.getElementById('transitionPoint'),
            transitionPointValue: document.getElementById('transitionPointValue'),
            showTransitionMarker: document.getElementById('showTransitionMarker'),
            outputFormat: document.getElementById('outputFormat'),
            transparentBg: document.getElementById('transparentBg'),
            previewBtn: document.getElementById('previewBtn'),
            generateBtn: document.getElementById('generateBtn'),
            previewCanvas: document.getElementById('previewCanvas'),
            canvasContainer: document.getElementById('canvasContainer'),
            transitionMarker: document.getElementById('transitionMarker'),
            playPreviewBtn: document.getElementById('playPreviewBtn'),
            previewProgress: document.getElementById('previewProgress'),
            generationStatus: document.getElementById('generationStatus'),
            downloadContainer: document.getElementById('downloadContainer'),
            downloadLink: document.getElementById('downloadLink'),
            newTransitionBtn: document.getElementById('newTransitionBtn')
        };

        // Global variables
        let ctx = elements.previewCanvas.getContext('2d');
        let uploadedImage = null;
        let audioContext = null;
        let audioBuffer = null;
        let audioSource = null;
        let audioGain = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isPreviewPlaying = false;
        let startTime = 0;
        let animationFrameId = null;
        let particles = [];

        // Initialize the application
        function init() {
            // Set canvas size
            elements.previewCanvas.width = CONFIG.width;
            elements.previewCanvas.height = CONFIG.height;
            
            // Set up event listeners
            setupEventListeners();
            
            // Update slider values display
            updateSliderValues();
            
            // Position transition marker
            updateTransitionMarker();
            
            // Show initial info message
            setStatusMessage('Upload an image to get started.', 'info');
        }

        // Set up event listeners for form controls
        function setupEventListeners() {
            // File uploads
            elements.imageUpload.addEventListener('change', handleImageUpload);
            elements.audioUpload.addEventListener('change', handleAudioUpload);
            
            // Sliders
            elements.particleDensity.addEventListener('input', updateSliderValues);
            elements.audioVolume.addEventListener('input', updateSliderValues);
            elements.transitionPoint.addEventListener('input', () => {
                updateSliderValues();
                updateTransitionMarker();
            });
            
            // Buttons
            elements.previewBtn.addEventListener('click', previewTransition);
            elements.generateBtn.addEventListener('click', generateVideo);
            elements.playPreviewBtn.addEventListener('click', togglePreviewPlayback);
            elements.newTransitionBtn.addEventListener('click', resetGenerator);
            
            // Show/hide transition marker
            elements.showTransitionMarker.addEventListener('change', updateTransitionMarker);
        }

        // Update displayed values for sliders
        function updateSliderValues() {
            elements.particleDensityValue.textContent = elements.particleDensity.value;
            elements.audioVolumeValue.textContent = `${elements.audioVolume.value}%`;
            elements.transitionPointValue.textContent = `${elements.transitionPoint.value}%`;
        }

        // Update the position of the transition marker
        function updateTransitionMarker() {
            if (elements.showTransitionMarker.checked) {
                const percentage = parseInt(elements.transitionPoint.value);
                elements.transitionMarker.style.left = `${percentage}%`;
                elements.transitionMarker.style.display = 'block';
            } else {
                elements.transitionMarker.style.display = 'none';
            }
        }

        // Handle image file upload
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    uploadedImage = img;
                    drawInitialImage();
                    setStatusMessage('Image loaded successfully. Click Preview to see the transition.', 'info');
                };
                img.src = e.target.result;
            };
            
            reader.onerror = function() {
                setStatusMessage('Error loading image. Please try again.', 'error');
            };
            
            reader.readAsDataURL(file);
        }

        // Handle audio file upload
        function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Initialize AudioContext if needed
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                audioContext.decodeAudioData(e.target.result)
                    .then(function(buffer) {
                        audioBuffer = buffer;
                        setStatusMessage('Audio loaded successfully.', 'info');
                    })
                    .catch(function(err) {
                        setStatusMessage('Error decoding audio file. Please try another file.', 'error');
                    });
            };
            
            reader.onerror = function() {
                setStatusMessage('Error loading audio file. Please try again.', 'error');
            };
            
            reader.readAsArrayBuffer(file);
        }

        // Draw the initial image on the canvas
        function drawInitialImage() {
            if (!uploadedImage) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
            
            // Draw image centered
            const aspectRatio = uploadedImage.width / uploadedImage.height;
            let drawWidth, drawHeight, x, y;
            
            if (aspectRatio > CONFIG.width / CONFIG.height) {
                // Image is wider than canvas proportionally
                drawWidth = CONFIG.width;
                drawHeight = CONFIG.width / aspectRatio;
                x = 0;
                y = (CONFIG.height - drawHeight) / 2;
            } else {
                // Image is taller than canvas proportionally
                drawHeight = CONFIG.height;
                drawWidth = CONFIG.height * aspectRatio;
                x = (CONFIG.width - drawWidth) / 2;
                y = 0;
            }
            
            // If transparent background is not checked, draw white background
            if (!elements.transparentBg.checked) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
            }
            
            ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
        }

        // Show status message to user
        function setStatusMessage(message, type) {
            elements.generationStatus.textContent = message;
            elements.generationStatus.className = 'status-message';
            
            if (type) {
                elements.generationStatus.classList.add(type);
            }
        }

        // Preview the transition
        function previewTransition() {
            if (!uploadedImage) {
                setStatusMessage('Please upload an image first.', 'error');
                return;
            }
            
            // Stop any ongoing preview
            stopPreviewPlayback();
            
            // Start preview animation
            isPreviewPlaying = true;
            startTime = performance.now();
            particles = createParticles();
            
            // Update UI
            elements.playPreviewBtn.textContent = 'Stop Preview';
            
            // Start animation loop
            animatePreview();
        }

        // Toggle preview playback (play/stop)
        function togglePreviewPlayback() {
            if (isPreviewPlaying) {
                stopPreviewPlayback();
            } else {
                previewTransition();
            }
        }

        // Stop preview playback
        function stopPreviewPlayback() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            isPreviewPlaying = false;
            elements.playPreviewBtn.textContent = 'Play Preview';
            elements.previewProgress.style.width = '0%';
            
            // Redraw initial state
            drawInitialImage();
            
            // Stop audio if playing
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
        }

        // Animate preview frame by frame
        function animatePreview() {
            const now = performance.now();
            const elapsed = now - startTime;
            const duration = parseInt(elements.transitionDuration.value);
            const holdTime = parseInt(elements.holdTime.value);
            const totalDuration = duration + holdTime;
            
            // Calculate progress (0 to 1)
            let progress = Math.min(elapsed / duration, 1);
            
            // Update progress bar
            const totalProgress = Math.min(elapsed / totalDuration, 1) * 100;
            elements.previewProgress.style.width = `${totalProgress}%`;
            
            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
            
            // Draw background if not transparent
            if (!elements.transparentBg.checked) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
            }
            
            // Apply selected transition effect
            applyTransitionEffect(progress);
            
            // Draw particles if enabled
            if (elements.particleEffect.value !== 'none') {
                updateAndDrawParticles(progress);
            }
            
            // Play audio if available
            if (audioBuffer && audioContext && !audioSource && progress === 0) {
                playAudio();
            }
            
            // Continue animation if still playing
            if (isPreviewPlaying && elapsed < totalDuration) {
                animationFrameId = requestAnimationFrame(animatePreview);
            } else if (elapsed >= totalDuration) {
                // Animation complete
                isPreviewPlaying = false;
                elements.playPreviewBtn.textContent = 'Play Preview';
                
                // Stop audio
                if (audioSource) {
                    audioSource.stop();
                    audioSource = null;
                }
            }
        }

        // Apply the selected transition effect
        function applyTransitionEffect(progress) {
            if (!uploadedImage) return;
            
            const effect = elements.transitionEffect.value;
            const { width, height } = CONFIG;
            
            // Calculate image dimensions and position
            const aspectRatio = uploadedImage.width / uploadedImage.height;
            let drawWidth, drawHeight, x, y;
            
            if (aspectRatio > width / height) {
                drawWidth = width;
                drawHeight = width / aspectRatio;
                x = 0;
                y = (height - drawHeight) / 2;
            } else {
                drawHeight = height;
                drawWidth = height * aspectRatio;
                x = (width - drawWidth) / 2;
                y = 0;
            }
            
            // Save context state
            ctx.save();
            
            // Apply effect based on selection
            switch(effect) {
                case 'leftToRight':
                    ctx.beginPath();
                    ctx.rect(0, 0, width * progress, height);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'rightToLeft':
                    ctx.beginPath();
                    ctx.rect(width * (1 - progress), 0, width * progress, height);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'topToBottom':
                    ctx.beginPath();
                    ctx.rect(0, 0, width, height * progress);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'bottomToTop':
                    ctx.beginPath();
                    ctx.rect(0, height * (1 - progress), width, height * progress);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'fade':
                    ctx.globalAlpha = progress;
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'zoom':
                    const scale = progress;
                    const scaledWidth = drawWidth * scale;
                    const scaledHeight = drawHeight * scale;
                    const scaledX = x + (drawWidth - scaledWidth) / 2;
                    const scaledY = y + (drawHeight - scaledHeight) / 2;
                    ctx.drawImage(uploadedImage, scaledX, scaledY, scaledWidth, scaledHeight);
                    break;
                    
                case 'pixelate':
                    const pixelSize = Math.max(1, Math.floor((1 - progress) * 30));
                    
                    // Create a temporary canvas for pixelation
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    
                    // Set small size for pixelation
                    tempCanvas.width = width / pixelSize;
                    tempCanvas.height = height / pixelSize;
                    
                    // Draw small image (pixelated)
                    tempCtx.drawImage(uploadedImage, x / pixelSize, y / pixelSize, 
                                     drawWidth / pixelSize, drawHeight / pixelSize);
                    
                    // Draw back to main canvas scaled up (blocky)
                    ctx.imageSmoothingEnabled = false;
                    ctx.drawImage(tempCanvas, 0, 0, tempCanvas.width, tempCanvas.height, 
                                 0, 0, width, height);
                    ctx.imageSmoothingEnabled = true;
                    break;
                    
                case 'circularWipe':
                    const radius = Math.sqrt(width * width + height * height) * progress;
                    ctx.beginPath();
                    ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'splitHorizontal':
                    // Top half
                    ctx.beginPath();
                    ctx.rect(0, 0, width, height / 2 - (height / 2 * (1 - progress)));
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    
                    ctx.restore();
                    ctx.save();
                    
                    // Bottom half
                    ctx.beginPath();
                    ctx.rect(0, height / 2 + (height / 2 * (1 - progress)), width, height / 2);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'splitVertical':
                    // Left half
                    ctx.beginPath();
                    ctx.rect(0, 0, width / 2 - (width / 2 * (1 - progress)), height);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    
                    ctx.restore();
                    ctx.save();
                    
                    // Right half
                    ctx.beginPath();
                    ctx.rect(width / 2 + (width / 2 * (1 - progress)), 0, width / 2, height);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'glitch':
                    const sliceHeight = height / 20;
                    const maxOffset = 20 * (1 - progress);
                    
                    for (let i = 0; i < 20; i++) {
                        const yPos = i * sliceHeight;
                        const xOffset = Math.random() * maxOffset * (Math.random() > 0.5 ? 1 : -1);
                        
                        ctx.drawImage(
                            uploadedImage,
                            0, (i / 20) * uploadedImage.height, uploadedImage.width, uploadedImage.height / 20,
                            x + xOffset, y + yPos, drawWidth, sliceHeight
                        );
                    }
                    break;
                    
                case 'blurToClear':
                    // Not true blur but a simplified version using scale
                    // For true blur, would need to use filters or multiple draws with offsets
                    ctx.filter = `blur(${(1 - progress) * 20}px)`;
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    ctx.filter = 'none';
                    break;
                    
                case 'grayscaleToColor':
                    // Draw grayscale version
                    ctx.filter = `grayscale(${1 - progress})`;
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    ctx.filter = 'none';
                    break;
                    
                case 'venetianBlinds':
                    const blinds = 10;
                    const blindHeight = height / blinds;
                    
                    for (let i = 0; i < blinds; i++) {
                        const blindY = i * blindHeight;
                        const blindWidth = width * progress;
                        
                        ctx.beginPath();
                        ctx.rect(0, blindY, blindWidth, blindHeight);
                        ctx.clip();
                        ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                        
                        ctx.restore();
                        
                        if (i < blinds - 1) {
                            ctx.save();
                        }
                    }
                    return; // Early return to avoid final restore
                    
                case 'diagonalWipe':
                    const diagProgress = progress * 2; // Go from 0-2 for full coverage
                    ctx.beginPath();
                    ctx.moveTo(0, height * (1 - Math.min(1, diagProgress)));
                    ctx.lineTo(Math.max(0, diagProgress - 1) * width, height);
                    ctx.lineTo(0, height);
                    ctx.closePath();
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
                    break;
                    
                case 'bounce':
                    // Elastic bounce effect
                    let bounceProgress;
                    if (progress < 0.7) {
                        // Scale from 0 to 1.2 for overshoot
                        bounceProgress = (progress / 0.7) * 1.2;
                    } else {
                        // Bounce back from 1.2 to 1.0
                        bounceProgress = 1.2 - (progress - 0.7) * (0.2 / 0.3);
                    }
                    
                    // Scale image with bounce effect
                    const bounceScale = bounceProgress;
                    const bounceWidth = drawWidth * bounceScale;
                    const bounceHeight = drawHeight * bounceScale;
                    const bounceX = x + (drawWidth - bounceWidth) / 2;
                    const bounceY = y + (drawHeight - bounceHeight) / 2;
                    
                    ctx.drawImage(uploadedImage, bounceX, bounceY, bounceWidth, bounceHeight);
                    break;
                    
                default:
                    // Default: just draw the image
                    ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
            }
            
            // Restore context state
            ctx.restore();
        }

        // Create particles based on selected effect
        function createParticles() {
            const particleType = elements.particleEffect.value;
            if (particleType === 'none') return [];
            
            const density = parseInt(elements.particleDensity.value);
            const color = elements.particleColor.value;
            const count = Math.floor(density * 2);
            const particles = [];
            
            for (let i = 0; i < count; i++) {
                const particle = {
                    x: Math.random() * CONFIG.width,
                    y: Math.random() * CONFIG.height,
                    size: Math.random() * 5 + 2,
                    speedX: Math.random() * 6 - 3,
                    speedY: Math.random() * 6 - 3,
                    color: color,
                    opacity: Math.random() * 0.7 + 0.3,
                    type: particleType,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() * 2 - 1) * 5
                };
                
                // Type-specific properties
                switch(particleType) {
                    case 'confetti':
                        particle.width = Math.random() * 10 + 5;
                        particle.height = Math.random() * 10 + 5;
                        break;
                        
                    case 'sparks':
                        particle.tail = Math.random() * 10 + 5;
                        particle.decay = Math.random() * 0.03 + 0.01;
                        break;
                        
                    case 'bubbles':
                        particle.maxSize = particle.size * (Math.random() * 2 + 2);
                        particle.growSpeed = Math.random() * 0.1 + 0.05;
                        break;
                        
                    case 'smoke':
                        particle.maxSize = particle.size * (Math.random() * 5 + 3);
                        particle.growSpeed = Math.random() * 0.1 + 0.05;
                        particle.decay = Math.random() * 0.01 + 0.005;
                        break;
                        
                    case 'stars':
                        particle.points = Math.floor(Math.random() * 3) + 4; // 4-6 point stars
                        particle.innerRadius = particle.size * 0.4;
                        particle.twinkle = Math.random() * 0.05 + 0.02;
                        particle.twinkleDir = 1;
                        break;
                }
                
                particles.push(particle);
            }
            
            return particles;
        }

        // Update and draw particles
        function updateAndDrawParticles(progress) {
            // Only show particles after a certain point in the animation
            if (progress < 0.3) return;
            
            const particleProgress = (progress - 0.3) / 0.7; // Remap 0.3-1.0 to 0-1
            const particleType = elements.particleEffect.value;
            
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // Only show a portion of particles based on progress
                if (i / particles.length > particleProgress) continue;
                
                // Update position based on speed
                p.x += p.speedX;
                p.y += p.speedY;
                p.rotation += p.rotationSpeed;
                
                // Type-specific updates
                switch(particleType) {
                    case 'confetti':
                        // Update rotation
                        p.rotation += p.rotationSpeed;
                        
                        // Draw confetti rect
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation * Math.PI / 180);
                        ctx.globalAlpha = p.opacity;
                        ctx.fillStyle = p.color;
                        ctx.fillRect(-p.width / 2, -p.height / 2, p.width, p.height);
                        ctx.restore();
                        break;
                        
                    case 'sparks':
                        // Reduce opacity over time
                        p.opacity -= p.decay;
                        
                        // Draw spark line
                        ctx.beginPath();
                        ctx.moveTo(p.x, p.y);
                        ctx.lineTo(p.x - p.speedX * p.tail, p.y - p.speedY * p.tail);
                        ctx.strokeStyle = p.color;
                        ctx.globalAlpha = p.opacity;
                        ctx.lineWidth = p.size;
                        ctx.stroke();
                        break;
                        
                    case 'bubbles':
                        // Grow bubbles
                        p.size = Math.min(p.maxSize, p.size + p.growSpeed);
                        
                        // Draw bubble
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.opacity * 0.7;
                        ctx.fill();
                        
                        // Draw highlight
                        ctx.beginPath();
                        ctx.arc(p.x - p.size * 0.3, p.y - p.size * 0.3, p.size * 0.2, 0, Math.PI * 2);
                        ctx.fillStyle = 'white';
                        ctx.globalAlpha = p.opacity * 0.5;
                        ctx.fill();
                        break;
                        
                    case 'smoke':
                        // Grow and fade smoke
                        p.size = Math.min(p.maxSize, p.size + p.growSpeed);
                        p.opacity -= p.decay;
                        
                        // Draw smoke circle
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.opacity * 0.4;
                        ctx.fill();
                        break;
                        
                    case 'stars':
                        // Twinkle effect
                        p.opacity += p.twinkle * p.twinkleDir;
                        if (p.opacity > 1 || p.opacity < 0.3) {
                            p.twinkleDir *= -1;
                        }
                        
                        // Draw star
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation * Math.PI / 180);
                        ctx.beginPath();
                        
                        for (let j = 0; j < p.points * 2; j++) {
                            const radius = j % 2 === 0 ? p.size : p.innerRadius;
                            const angle = (j * Math.PI) / p.points;
                            const x = radius * Math.cos(angle);
                            const y = radius * Math.sin(angle);
                            
                            if (j === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        
                        ctx.closePath();
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.opacity;
                        ctx.fill();
                        ctx.restore();
                        break;
                }
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1;
        }

        // Play audio with volume control
        function playAudio() {
            if (!audioBuffer || !audioContext) return;
            
            // Create source and gain nodes
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            
            audioGain = audioContext.createGain();
            audioGain.gain.value = parseInt(elements.audioVolume.value) / 100;
            
            // Connect nodes
            audioSource.connect(audioGain);
            audioGain.connect(audioContext.destination);
            
            // Start playback
            audioSource.start(0);
        }

        // Generate video file
        function generateVideo() {
            if (!uploadedImage) {
                setStatusMessage('Please upload an image first.', 'error');
                return;
            }
            
            // Check browser support
            if (!window.MediaRecorder) {
                setStatusMessage('Your browser does not support the MediaRecorder API. Please try a modern browser like Chrome or Firefox.', 'error');
                return;
            }
            
            // Get settings
            const duration = parseInt(elements.transitionDuration.value);
            const holdTime = parseInt(elements.holdTime.value);
            const totalDuration = duration + holdTime;
            const format = elements.outputFormat.value;
            const transitionPoint = parseInt(elements.transitionPoint.value);
            
            // Set up MIME type based on format
            let mimeType;
            if (format === 'webm') {
                mimeType = 'video/webm;codecs=vp8';
            } else {
                mimeType = 'video/mp4';
            }
            
            // Check if format is supported
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                setStatusMessage(`Your browser does not support recording ${format.toUpperCase()} video. Please try another format.`, 'error');
                return;
            }
            
            // Set up canvas stream
            const stream = elements.previewCanvas.captureStream(CONFIG.fps);
            
            // Add audio track if available
            if (audioBuffer && audioContext) {
                const audioDestination = audioContext.createMediaStreamDestination();
                
                audioSource = audioContext.createBufferSource();
                audioSource.buffer = audioBuffer;
                
                audioGain = audioContext.createGain();
                audioGain.gain.value = parseInt(elements.audioVolume.value) / 100;
                
                audioSource.connect(audioGain);
                audioGain.connect(audioDestination);
                
                stream.addTrack(audioDestination.stream.getAudioTracks()[0]);
            }
            
            // Set up media recorder
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: mimeType,
                videoBitsPerSecond: 5000000 // 5 Mbps
            });
            
            // Clear previous recorded chunks
            recordedChunks = [];
            
            // Set up event handlers
            mediaRecorder.ondataavailable = function(e) {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };
            
            mediaRecorder.onstop = function() {
                // Create Blob from recorded chunks
                const blob = new Blob(recordedChunks, { type: mimeType });
                
                // Create download URL
                const url = URL.createObjectURL(blob);
                
                // Set download link
                elements.downloadLink.href = url;
                elements.downloadLink.download = `transition_${transitionPoint}pt.${format}`;
                
                // Show download section
                elements.downloadContainer.style.display = 'flex';
                
                setStatusMessage(`Transition generated successfully! Transition point is at ${transitionPoint}%.`, 'success');
            };
            
            // Start recording
            mediaRecorder.start();
            
            // Prepare animation
            isPreviewPlaying = true;
            startTime = performance.now();
            particles = createParticles();
            
            // Start audio if available
            if (audioBuffer && audioContext && audioSource) {
                audioSource.start(0);
            }
            
            // Update UI
            setStatusMessage('Generating video... Please wait.', 'info');
            elements.generateBtn.disabled = true;
            elements.previewBtn.disabled = true;
            
            // Set up animation interval
            const recordingStartTime = performance.now();
            
            function recordFrame() {
                const now = performance.now();
                const elapsed = now - recordingStartTime;
                
                if (elapsed >= totalDuration) {
                    // Recording complete
                    mediaRecorder.stop();
                    isPreviewPlaying = false;
                    
                    // Stop audio
                    if (audioSource) {
                        audioSource.stop();
                        audioSource = null;
                    }
                    
                    // Reset UI
                    elements.generateBtn.disabled = false;
                    elements.previewBtn.disabled = false;
                    elements.previewProgress.style.width = '100%';
                    
                    return;
                }
                
                // Calculate progress (0 to 1)
                let progress;
                if (elapsed <= duration) {
                    progress = elapsed / duration;
                } else {
                    progress = 1; // Hold at final frame
                }
                
                // Update progress bar
                const totalProgress = Math.min(elapsed / totalDuration, 1) * 100;
                elements.previewProgress.style.width = `${totalProgress}%`;
                
                // Clear canvas
                ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
                
                // Draw background if not transparent
                if (!elements.transparentBg.checked) {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, CONFIG.width, CONFIG.height);
                }
                
                // Apply transition effect
                applyTransitionEffect(progress);
                
                // Draw particles if enabled
                if (elements.particleEffect.value !== 'none') {
                    updateAndDrawParticles(progress);
                }
                
                // Continue recording
                requestAnimationFrame(recordFrame);
            }
            
            // Start recording frames
            recordFrame();
        }

        // Reset the generator for a new transition
        function resetGenerator() {
            // Stop any ongoing preview
            stopPreviewPlayback();
            
            // Reset audio
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);
            
            // Hide download section
            elements.downloadContainer.style.display = 'none';
            
            // Reset progress
            elements.previewProgress.style.width = '0%';
            
            // Enable buttons
            elements.generateBtn.disabled = false;
            elements.previewBtn.disabled = false;
            
            // Clear status message
            setStatusMessage('Ready to create a new transition.', 'info');
        }

        // Check browser compatibility
        function checkBrowserCompatibility() {
            const incompatibilities = [];
            
            if (!window.MediaRecorder) {
                incompatibilities.push('MediaRecorder API');
            }
            
            if (typeof elements.previewCanvas.captureStream !== 'function') {
                incompatibilities.push('Canvas.captureStream()');
            }
            
            if (!window.AudioContext && !window.webkitAudioContext) {
                incompatibilities.push('Web Audio API');
            }
            
            if (incompatibilities.length > 0) {
                setStatusMessage(`Your browser doesn't support: ${incompatibilities.join(', ')}. Some features may not work correctly. Please use a modern browser like Chrome or Firefox.`, 'error');
                return false;
            }
            
            return true;
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', function() {
            init();
            checkBrowserCompatibility();
        });
    </script>
</body>
</html>